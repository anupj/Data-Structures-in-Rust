///  Takes in a string as an argument. The function should
///  return an array containing all of the strings that
///  could be generated by expanding all parentheses of the
///  string into its possibilities.
///  
/// For example, the possibilities for 'x(mn)yz' are 'xmyz', 'xnyz'.
pub fn parenthetical_possibilities(s: &str) -> Vec<String> {
    if s.is_empty() {
        return vec![String::new()];
    }

    let (remaining, chars) = get_options(s);
    let suffixes = parenthetical_possibilities(&remaining);
    let mut possibilities: Vec<String> = Vec::new();

    for ch in chars {
        for suffix in &suffixes {
            let mut new_possibility = ch.clone();
            new_possibility.push_str(suffix);
            possibilities.push(new_possibility);
        }
    }

    possibilities
}

fn get_options(s: &str) -> (String, Vec<String>) {
    if s.starts_with('(') {
        let end_idx = s.find(')').unwrap();
        let remaining = s[end_idx + 1..].to_string();
        let chars: Vec<String> = s[1..end_idx].chars().map(|c| c.to_string()).collect();
        (remaining, chars)
    } else {
        let remaining = s[1..].to_string();
        let chars = vec![s.chars().next().unwrap().to_string()];
        (remaining.to_string(), chars)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parenthetical_possibilities_00() {
        let result = parenthetical_possibilities("x(mn)yz");
        assert_eq!(result, vec!["xmyz", "xnyz"]);
    }

    #[test]
    fn parenthetical_possibilities_01() {
        let result = parenthetical_possibilities("x(mn)yz");
        assert_eq!(result, vec!["xmyz", "xnyz"]);
    }

    #[test]
    fn parenthetical_possibilities_02() {
        let result = parenthetical_possibilities("(qr)ab(stu)c");
        assert_eq!(
            result,
            vec!["qabsc", "qabtc", "qabuc", "rabsc", "rabtc", "rabuc"]
        );
    }

    #[test]
    fn parenthetical_possibilities_03() {
        let result = parenthetical_possibilities("taco");
        assert_eq!(result, vec!["taco"]);
    }

    #[test]
    fn parenthetical_possibilities_04() {
        let result = parenthetical_possibilities("");
        assert_eq!(result, vec![""]);
    }

    #[test]
    fn parenthetical_possibilities_05() {
        let result = parenthetical_possibilities("(etc)(blvd)(cat)");
        assert_eq!(
            result,
            vec![
                "ebc", "eba", "ebt", "elc", "ela", "elt", "evc", "eva", "evt", "edc", "eda", "edt",
                "tbc", "tba", "tbt", "tlc", "tla", "tlt", "tvc", "tva", "tvt", "tdc", "tda", "tdt",
                "cbc", "cba", "cbt", "clc", "cla", "clt", "cvc", "cva", "cvt", "cdc", "cda", "cdt"
            ]
        );
    }
}
